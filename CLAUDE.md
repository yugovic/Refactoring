# 3D Asset Placement - 開発ガイドライン

## 重要：ドキュメント管理ルール
- **完了したタスクは削除しない**：履歴として保持し、実施内容と学びを記録する
- **日付形式**：YYYY-MM-DD形式で統一（例：2025-06-23）
- **実装から得た学びは必ず記録**：問題解決のプロセスと教訓を明文化する

## プロジェクト概要
3Dアセット配置システムの開発ガイドラインと拡張仕様

## 配置可能サーフェスの拡張仕様

### 命名規則
GLBファイル内のメッシュ名で配置可能な場所を定義する際の命名規則：

- `placeable_` プレフィックスを使用して配置可能サーフェスを明示
- 例：
  - `placeable_seat_surface` - シートの座面
  - `placeable_car_roof` - 車の屋根  
  - `placeable_table_top` - テーブルの天板
  - `placeable_shelf` - 棚板

### メタデータ構造
```javascript
metadata: {
    isPlaceable: true,
    placeableType: "seat_surface",
    maxWeight: 10,  // kg単位の重量制限
    dimensions: { width: 0.5, depth: 0.5 },  // メートル単位
    allowedAssetTypes: ["small_items", "food", "decorations"]
}
```

## サイズ制約の実装アイデア

### 1. バウンディングボックスによる判定
配置前に以下をチェック：
- 配置するアセットのバウンディングボックスサイズ
- 配置可能エリアの寸法
- アセットが配置可能エリア内に収まるか検証

### 2. オーバーラップ検出
- 既存の配置済みアセットとの衝突判定
- 最小間隔の設定（例：5cm以上離す）
- Z-ファイティング防止のための高さオフセット

### 3. エッジ検出とはみ出し防止
- 配置可能エリアの境界計算
- アセットの中心点だけでなく、全体が収まるか確認
- エッジからの最小マージン設定

## 階層的な配置ルール

### ルール定義の例
```javascript
const placeableRules = {
    "seat_surface": {
        allowedAssets: ["small_items", "food", "bags"],
        maxSize: { x: 0.5, y: 0.5, z: 0.5 },
        maxWeight: 5,
        placement: "top_only"  // 上面のみ配置可
    },
    "car_roof": {
        allowedAssets: ["luggage", "decorations", "carrier"],
        maxSize: { x: 2, y: 1, z: 2 },
        maxWeight: 50,
        placement: "top_only"
    },
    "wall": {
        allowedAssets: ["pictures", "decorations", "small_shelf"],
        maxSize: { x: 0.1, y: 1, z: 1 },
        placement: "surface"  // 壁面に配置
    }
}
```

## 開発履歴

### 2025-06-22 実施タスク
1. **バウンディングボックス問題の解決**
   - GLBファイルロード時の親メッシュのバウンディングボックスがゼロサイズになる問題を修正
   - 全車両・アセットに対してrecalculateParentBoundingメソッドを適用

2. **大規模ファイルのモジュール化**
   - UIManager (1417行) → 12モジュール構成に分割
   - AssetPlacer (1329行) → 8モジュール構成に分割
   - ファサードパターンで既存インターフェースとの互換性を維持

3. **車両フォーカス機能の改善**
   - オルソグラフィックカメラでのズーム方向を修正（ズームアウト→ズームイン）
   - フォーカスボタンのトグル動作実装
   - ズーム距離の微調整（少し控えめに）

4. **車両上へのアセット配置防止**
   - InteractionManagerで車両メッシュパターンを検出
   - 車両をスキップして床を再ピッキングする処理を実装

## 実装の段階的アプローチ

### 第1段階：基本的な配置可否判定
- メッシュ名による判定（現在の実装）
- `placeable_`プレフィックスの追加サポート

### 第2段階：サイズ制約の追加
- バウンディングボックスの計算
- 配置可能エリアとのサイズ比較
- 視覚的フィードバック（赤/緑のハイライト）

### 第3段階：物理的な配置計算
- メッシュの正確な形状を考慮
- 複雑な形状での配置可能エリア計算
- 重なり防止の高度なアルゴリズム

### 第4段階：高度な視覚的フィードバック
- 配置可能エリアのハイライト表示
- ゴーストプレビューでの配置可否表示
- 配置ガイドライン（グリッド、スナップポイント）

## 技術的考慮事項

### パフォーマンス最適化
- 配置可能チェックのキャッシング
- 空間分割による衝突判定の高速化
- LOD（Level of Detail）を考慮した判定

### 互換性の維持
- 既存のfloor/wall判定との共存
- 段階的な機能追加での後方互換性確保
- メタデータのバージョニング

## 技術的な学び：バウンディングボックス計算における親メッシュと子メッシュの使い分け

### 2025-06-23 発生した問題と解決

#### 問題の概要
Paul FenceとCondenserなどのファシリティアセットで、プレビューは正しく表示されるが、実際の配置時に床に沈み込む問題が発生。

#### 原因
```javascript
// ❌ 問題のあったコード
if (childMeshes.length > 0) {
    // 最初の子メッシュのバウンディングボックスのみを使用
    boundingInfo = validChildren[0].getBoundingInfo();
}
```
- **誤った仮定**：「最初の子メッシュ = 最下部のメッシュ」
- **設計の誤解**：「子メッシュがある場合は子メッシュを使うべき」

#### 解決策
```javascript
// ✅ 修正後のコード
// 親メッシュのバウンディングボックスを直接使用（最も効率的）
const boundingInfo = mesh.getBoundingInfo();
```

### バウンディングボックス戦略の使い分けガイドライン

#### 1. 親メッシュのバウンディングボックスを使用すべき場合
- **床への配置計算**（現在の用途）
- **大まかな領域判定**
- **パフォーマンスが重要な場合**
- **シンプルな形状のアセット**

**メリット**：
- 高速（O(1)）
- 実装がシンプル
- Babylon.jsが自動的に全子メッシュを考慮

#### 2. 子メッシュのバウンディングボックスを使用すべき場合
- **精密な衝突判定**
- **複雑な形状（L字型建物など）**
- **物理シミュレーション**
- **隙間への配置判定**

**メリット**：
- より正確な判定
- 無駄な空間を含まない
- 複雑な形状に対応可能

**デメリット**：
- 計算コスト（O(N)）
- 実装が複雑
- メモリ使用量が増加

### 重要な教訓
1. **仮定より検証**：配列の順序について仮定せず、実際のデータ構造を確認する
2. **既存の仕組みを活用**：Babylon.jsの親バウンディング計算は既に最適化されている
3. **用途に応じた選択**：「常に子メッシュ」「常に親メッシュ」ではなく、状況に応じて使い分ける
4. **パフォーマンスを考慮**：より複雑な解決策が必ずしも良いとは限らない

## バックログ管理

### 実装予定の機能

#### 最優先タスク
- [ ] **バウンディングスフィアと接触判定の関係を調査**
  - 調査内容：10%スケールのアセットのバウンディングスフィアが各種判定に与える影響
  - 確認項目：ピッキング判定、衝突検出、カメラズーム計算への影響
  - 目的：小さすぎるバウンディングスフィアが原因の不具合を特定し修正
- [ ] **バウンディングボックスの表示機能を正しく動作させる**
  - 現状：チェックボックスをオンにしても配置済みアセットのバウンディングボックスが表示されない
  - 目的：各アセットの実際の当たり判定範囲を可視化し、不適切なサイズの問題を特定する
  - 次のステップ：バウンディングボックスのサイズを適切に調整し、「見た目は床が空いているのに配置できない」問題を解決

#### コア機能
- [ ] 配置可能サーフェスの実装（placeable_プレフィックス対応）
- [ ] アセットのバウンディングボックスによるサイズ制約チェック
- [ ] 配置済みアセット同士の衝突判定
- [ ] 配置可能エリアの視覚的ハイライト
- [ ] アセットタイプごとの配置ルール実装
- [ ] カメラ遷移機能（特定ボタンで車両にフォーカス・パン）
- [ ] 動的アセット対応（アニメーション付きキャラクター等）
- [ ] 物理演算の導入検討（ボールが落下・転がる等）
- [ ] 配置可能箇所の定義を1箇所に集約（現在は複数箇所に分散）

#### UX/UI改善
- [ ] アセットサイズ変更のUI改善（より直感的な操作）
- [ ] 連続配置モード（同じアセットを複数配置しやすく）
- [ ] 車両・アセット配置UI全体の再設計

#### ゲーム性・コンセプト
- [ ] アセットの3群構成の設計
  - 車両群（メインアセット）
  - ファシリティ群（基本的な家具・設備）
  - パーソナリティ群（趣味・個性を表現するキーアセット）
- [ ] 「車のある生活の良さ」を表現するアセット選定
- [ ] アセット群のUI上での効果的な表現方法

#### デバッグ機能
- [ ] メッシュ表示デバッグモード
- [ ] タッチしたメッシュ情報の表示（メッシュ名、親アセット名）

### 既知の課題
- [ ] アセットの上にアセットを重ねて配置できてしまう問題
- [ ] 小さな配置可能エリアに大きなアセットを配置できてしまう問題
- [ ] バウンディングボックスが配置時に一瞬しか表示されない（継続表示されない）
- [ ] 車両配置時に部屋の境界外に配置できてしまう（境界チェックを追加したが要確認）

### 完了した機能
- [x] アセットサイズを10%標準、1-100%スライダー調整
- [x] 車両サイズ調整機能
- [x] Body85問題の修正（bodyを床として認識しないように変更）
- [x] トロフィーアセットの追加（assets/Basic/TrophyFree.glb）
- [x] BGM再生機能（HTML5 Audio使用）
- [x] 音量調整スライダー
- [x] **バウンディングボックス問題の解決**（2025-06-22）
  - GLBアセットの親メッシュのバウンディングボックスがゼロサイズになる問題を修正
  - recalculateParentBounding メソッドを実装し、子メッシュから正確な境界を計算
- [x] **大規模ファイルのリファクタリング**（2025-06-22）
  - UIManager (1417行) を12個のモジュールに分割
  - AssetPlacer (1329行) を8個のモジュールに分割
  - 責任の分離とモジュール化により保守性を大幅に向上
- [x] **車両フォーカス機能の実装**（2025-06-22）
  - 車両にスムーズにズームインするカメラアニメーション
  - オルソグラフィックモードでの適切なズーム計算
  - フォーカスボタンのトグル動作（2回目のクリックで元に戻る）
- [x] **車両上へのアセット配置防止**（2025-06-22）
  - 車両メッシュを検出して自動的に床を再ピッキング
  - 車両の子メッシュパターンを認識して適切に除外
- [x] **ファシリティアセットの配置問題修正**（2025-06-23）
  - プレビューメッシュが表示されない問題を修正（パス誤り：FacilityItems → Facilities）
  - 複数配置できない問題を修正（メッシュキャッシュとdoNotDisposeフラグの実装）
  - アセットが床に沈む問題を解決（親メッシュのバウンディングボックスを使用）
  - 技術的な学びをドキュメント化（親vs子メッシュのバウンディングボックス使用方針）
- [x] **アセット回転ボタンの実装**（2025-06-24）
  - 配置済みアセット選択時に3D空間に回転ボタンを表示
  - ボタンは常にカメラに向く（ビルボード）
  - クリックで90度回転アニメーション
  - ホバー時の視覚的フィードバック（拡大・カーソル変更）
  - AssetRotationUIクラスとして独立実装し、SelectionControllerに統合
  - /assets/Rotate.pngを使用したアイコン表示に変更
  - InteractionManagerで回転ボタンのクリックを適切に除外

### 技術的債務
- [ ] 配置判定が点ベースで面積を考慮していない
- [ ] 配置可能エリアの判定がメッシュ名のみに依存
- [ ] **バウンディングスフィアのサイズが接触判定に与える影響の調査**
  - 現象：車両のスケールが10%のため、バウンディングスフィアが小さい
  - 懸念点：小さすぎるバウンディングスフィアが原因で、配置時の衝突検出やピッキング判定に問題が生じている可能性
  - 調査項目：
    - バウンディングスフィアとバウンディングボックスのサイズ差
    - ピッキング（クリック検出）への影響
    - 将来実装予定の衝突判定への影響
    - GSAPズーム機能での距離計算への影響（確認済み）
- [x] **ソースコードのリファクタリング**（2025-06-22）
  - UIManager（1417行）とAssetPlacer（1329行）を適切なサイズに分割完了
  - InteractionManagerは現在のサイズを維持（責任範囲が明確なため）
  - リファクタリング実績：
    - UIManager → 12モジュール構成
    - AssetPlacer → 8モジュール構成
    - ファサードパターンで既存インターフェースとの互換性を維持

## 開発時のTips

### ブラウザキャッシュの対処法
JavaScriptファイルを修正した後、変更が反映されない場合：

1. **ハード再読み込み**
   - Chrome/Edge: `Ctrl+Shift+R` (Windows) / `Cmd+Shift+R` (Mac)
   - Firefox: `Ctrl+F5` (Windows) / `Cmd+Shift+R` (Mac)

2. **開発者ツールでキャッシュ無効化**
   - F12で開発者ツールを開く
   - Networkタブ → 「Disable cache」にチェック
   - 開発者ツールを開いている間のみ有効

3. **キャッシュの消去とハード再読み込み**
   - 開発者ツールを開いた状態で
   - リロードボタンを右クリック
   - 「キャッシュの消去とハード再読み込み」を選択

### 開発サーバーの起動方法
```bash
# Python 3
python3 -m http.server 8000

# Node.js (npx)
npx http-server -p 8000

# VS Code Live Server
# index.htmlを右クリック → "Open with Live Server"
```

## コマンドメモ

### リント・型チェックコマンド
プロジェクトで使用するリント・型チェックコマンドを記録してください：
```bash
# 例：
# npm run lint
# npm run typecheck
```

## 説明スタイル定義（explainコマンド）

`explain`コマンドを使用した場合、以下の2つのスタイルで同時に説明を行う：

### 🌟 子供向けの説明
- 平易な言葉を使う（ただし漢字は通常通り使用可）
- 身近な例えや比喩を多用
- 具体的でイメージしやすい説明
- 楽しく興味を持てるような表現

### 📚 初心者向けの説明
- 専門用語は必ず丁寧に解説
- ステップバイステップで論理的に説明
- 実例やコード例を多く含める
- なぜそうなるのか理由と背景も説明

### 使用方法
```bash
# 直前のやりとりについて説明
explain

# 特定のトピックについて説明
explain プログラミング
```